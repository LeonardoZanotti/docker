{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is this guide and requisites WTF is this? This guide talks about docker images and containers, the basic commands, how to use docker and docker compose and how to create your own image. Requisites Docker Docker Compose You can install docker using: $ curl -fsSL https://get.docker.com/ -o get-docker.sh sudo sh get-docker.sh Or in debian derivade linux, you can also use: $ sudo apt install docker docker.io To install docker-compose, use: $ sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose Verify installation of both requisites: $ docker -v # verify currently docker installed version $ docker-compose -v # verify currently docker-compose installed version","title":"Home"},{"location":"#what-is-this-guide-and-requisites","text":"","title":"What is this guide and requisites"},{"location":"#wtf-is-this","text":"This guide talks about docker images and containers, the basic commands, how to use docker and docker compose and how to create your own image.","title":"WTF is this?"},{"location":"#requisites","text":"Docker Docker Compose You can install docker using: $ curl -fsSL https://get.docker.com/ -o get-docker.sh sudo sh get-docker.sh Or in debian derivade linux, you can also use: $ sudo apt install docker docker.io To install docker-compose, use: $ sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose Verify installation of both requisites: $ docker -v # verify currently docker installed version $ docker-compose -v # verify currently docker-compose installed version","title":"Requisites"},{"location":"docker-compose/","text":"Docker compose Docker can create one container with just one image (each image can create only one application). But, if we need to run many applications at the same time? We can use docker compose which groups the images in a document called docker-compose.yml . Running hello-world image with docker-compose Lets create a test: $ mkdir hello-world # create some dir $ cd hello-world # enter it $ nano docker-compose.yml # create and open docker-compose.yml Now, inside the doc you put the basic configuration: my-test: image: hello-world This tells to docker that the container name is my-test and the image to be runned is hello-world . Now if you see your images: $ sudo docker images Probably you will see: Output REPOSITORY TAG IMAGE ID CREATED SIZE Then run inside the docker-compose.yml directory: $ sudo docker-compose up # You will run the hello-world test script Now, if you run sudo docker images again or sudo docker ps -a you will be able to see the container created by docker-compose. Deploying a project with nginx image in docker-compose Another test: $ mkdir my-second-test $ cd my-second-test $ touch docker-compose.yml $ mkdir app $ cd app/ $ touch index.html Inside index.html you can put something like: !doctype html html lang= en head meta charset= utf-8 title Docker Compose Demo /title link rel= stylesheet href= https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css /head body h1 This is a Docker Compose Demo Page. /h1 p This content is being served by an Nginx container. /p /body /html And inside docker-compose.yml you should put this: version: '3.7' services: web: image: nginx:alpine ports: - 8000:80 volumes: - ./app:/usr/share/nginx/html Then, what we have? A html test file and the docker compose yml file. The yml file shows the version of docker-compose configurations and the services (in this case, just web ). The web service has the image, that is nginx (it will deploy our html file), also has the port of deploy (8000 in our machine, but in the container it will be 80, which is the nginx port) and the volumes, which is where our application will be saved in the containers (we are defining that the app folder inside this directory will be saved as /usr/share/nginx/html in the container, which is the nginx projects path). To run it: $ sudo docker-compose up -d # -d is to run in second plan, so you can use the terminal If you run sudo docker-compose ps or sudo docker ps you will see something like this: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ef2d797f0157 nginx:alpine /docker-entrypoint.\u2026 2 minutes ago Up About a minute 0.0.0.0:8000- 80/tcp files_web_1 Then, just open localhost:8000 and see the project running: If you see Forbidden 403, probably its because the folder in the container doesnt have permission, so just run: $ sudo docker exec container_id chmod 755 /usr/share/nginx/html/index.html Some more docker-compose commands How docker-compose works with directories containers, you dont pass any name or id in the commands (just stay in the container directory). To list the containers $ sudo docker-compose ps Upping a container $ sudo docker-compose up # can use -d to second plan container Down a container $ sudo docker-compose down See logs $ sudo docker-compose logs Pause/unpause a container $ sudo docker-compose pause $ sudo docker-compose unpause Stop the container $ sudo docker-compose stop You can just run docker-compose and see the full list: Commands: build Build or rebuild services config Validate and view the Compose file create Create services down Stop and remove containers, networks, images, and volumes events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show version information and quit Using docker-compose to create a laravel ambient [Building...] References Docker Compose on Ubuntu Docker Compose install and use","title":"Docker Compose"},{"location":"docker-compose/#docker-compose","text":"Docker can create one container with just one image (each image can create only one application). But, if we need to run many applications at the same time? We can use docker compose which groups the images in a document called docker-compose.yml .","title":"Docker compose"},{"location":"docker-compose/#running-hello-world-image-with-docker-compose","text":"Lets create a test: $ mkdir hello-world # create some dir $ cd hello-world # enter it $ nano docker-compose.yml # create and open docker-compose.yml Now, inside the doc you put the basic configuration: my-test: image: hello-world This tells to docker that the container name is my-test and the image to be runned is hello-world . Now if you see your images: $ sudo docker images Probably you will see: Output REPOSITORY TAG IMAGE ID CREATED SIZE Then run inside the docker-compose.yml directory: $ sudo docker-compose up # You will run the hello-world test script Now, if you run sudo docker images again or sudo docker ps -a you will be able to see the container created by docker-compose.","title":"Running hello-world image with docker-compose"},{"location":"docker-compose/#deploying-a-project-with-nginx-image-in-docker-compose","text":"Another test: $ mkdir my-second-test $ cd my-second-test $ touch docker-compose.yml $ mkdir app $ cd app/ $ touch index.html Inside index.html you can put something like: !doctype html html lang= en head meta charset= utf-8 title Docker Compose Demo /title link rel= stylesheet href= https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css /head body h1 This is a Docker Compose Demo Page. /h1 p This content is being served by an Nginx container. /p /body /html And inside docker-compose.yml you should put this: version: '3.7' services: web: image: nginx:alpine ports: - 8000:80 volumes: - ./app:/usr/share/nginx/html Then, what we have? A html test file and the docker compose yml file. The yml file shows the version of docker-compose configurations and the services (in this case, just web ). The web service has the image, that is nginx (it will deploy our html file), also has the port of deploy (8000 in our machine, but in the container it will be 80, which is the nginx port) and the volumes, which is where our application will be saved in the containers (we are defining that the app folder inside this directory will be saved as /usr/share/nginx/html in the container, which is the nginx projects path). To run it: $ sudo docker-compose up -d # -d is to run in second plan, so you can use the terminal If you run sudo docker-compose ps or sudo docker ps you will see something like this: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ef2d797f0157 nginx:alpine /docker-entrypoint.\u2026 2 minutes ago Up About a minute 0.0.0.0:8000- 80/tcp files_web_1 Then, just open localhost:8000 and see the project running: If you see Forbidden 403, probably its because the folder in the container doesnt have permission, so just run: $ sudo docker exec container_id chmod 755 /usr/share/nginx/html/index.html","title":"Deploying a project with nginx image in docker-compose"},{"location":"docker-compose/#some-more-docker-compose-commands","text":"How docker-compose works with directories containers, you dont pass any name or id in the commands (just stay in the container directory). To list the containers $ sudo docker-compose ps Upping a container $ sudo docker-compose up # can use -d to second plan container Down a container $ sudo docker-compose down See logs $ sudo docker-compose logs Pause/unpause a container $ sudo docker-compose pause $ sudo docker-compose unpause Stop the container $ sudo docker-compose stop You can just run docker-compose and see the full list: Commands: build Build or rebuild services config Validate and view the Compose file create Create services down Stop and remove containers, networks, images, and volumes events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show version information and quit","title":"Some more docker-compose commands"},{"location":"docker-compose/#using-docker-compose-to-create-a-laravel-ambient","text":"[Building...]","title":"Using docker-compose to create a laravel ambient"},{"location":"docker-compose/#references","text":"Docker Compose on Ubuntu Docker Compose install and use","title":"References"},{"location":"docker/","text":"Docker Understanding Docker The principal news about Docker is that Docker let us group an application or a collection of services in containers, so, we can access all the services by accessing the container (we will talk about generating a container wich many services in Docker compose page ). Basically, a docker container is an example of application that has all the librarys and components needed to an application works. For a pratice point of view, a container is like a reduced virtual machine that works regardless of an operational system where a specific application or service is executed. A docker container is generated by an image, which is the result of an application or group of services. It can have a complete operating system or several applications installed. We also can create an image, which we will see in this article too (see Create your own image page ). You can find some images to run in docker in the DockerHub . Test If your docker is correctly installed you can run this to test it: $ sudo docker run hello-world Images Search for images, then you can download the with the pull command (see ahead): $ sudo docker search [search_query] As example, if you want to search for Debian images you can use: $ sudo docker search debian Download an image to your machine: $ sudo docker pull [image_name] # Example: sudo docker pull debian Remove and image from your machine: $ docker rmi image_name_or_ID List images already downloaded: $ sudo docker images Run the image to create the container: $ sudo docker run -it [image] # The -it instructs Docker to allocate a pseudo-TTY connected to the container\u2019s stdin, # creating an interactive bash shell in the container. You can end the image running using CTRL + D . Containers You can list the containers running using: $ docker ps -a # use -qa to list only the id You can stop the container running with: $ sudo docker stop container_ID To start it again: $ sudo docker start container_ID You can remove an container using: $ docker rm container_ID You can execute commands in the container terminal with: $ sudo docker exec -it container_name_or_ID /bin/bash More commands You can find more commands using just: $ docker Or, to see the help for a specific command: $ docker docker-subcommand --help Output of docker command: Management Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a containers changes cp Copy files/folders between a container and the local filesystem create Create a new container deploy Deploy a new stack or update an existing stack diff Inspect changes to files or directories on a containers filesystem events Get real time events from the server exec Run a command in a running container export Export a containers filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Removing docker To remove Docker (noooo) in debian derivade linux: $ sudo apt-get remove docker docker-engine docker.io References Imagem e container Docker Docker command line Docker Docs","title":"Docker"},{"location":"docker/#docker","text":"","title":"Docker"},{"location":"docker/#understanding-docker","text":"The principal news about Docker is that Docker let us group an application or a collection of services in containers, so, we can access all the services by accessing the container (we will talk about generating a container wich many services in Docker compose page ). Basically, a docker container is an example of application that has all the librarys and components needed to an application works. For a pratice point of view, a container is like a reduced virtual machine that works regardless of an operational system where a specific application or service is executed. A docker container is generated by an image, which is the result of an application or group of services. It can have a complete operating system or several applications installed. We also can create an image, which we will see in this article too (see Create your own image page ). You can find some images to run in docker in the DockerHub .","title":"Understanding Docker"},{"location":"docker/#test","text":"If your docker is correctly installed you can run this to test it: $ sudo docker run hello-world","title":"Test"},{"location":"docker/#images","text":"Search for images, then you can download the with the pull command (see ahead): $ sudo docker search [search_query] As example, if you want to search for Debian images you can use: $ sudo docker search debian Download an image to your machine: $ sudo docker pull [image_name] # Example: sudo docker pull debian Remove and image from your machine: $ docker rmi image_name_or_ID List images already downloaded: $ sudo docker images Run the image to create the container: $ sudo docker run -it [image] # The -it instructs Docker to allocate a pseudo-TTY connected to the container\u2019s stdin, # creating an interactive bash shell in the container. You can end the image running using CTRL + D .","title":"Images"},{"location":"docker/#containers","text":"You can list the containers running using: $ docker ps -a # use -qa to list only the id You can stop the container running with: $ sudo docker stop container_ID To start it again: $ sudo docker start container_ID You can remove an container using: $ docker rm container_ID You can execute commands in the container terminal with: $ sudo docker exec -it container_name_or_ID /bin/bash","title":"Containers"},{"location":"docker/#more-commands","text":"You can find more commands using just: $ docker Or, to see the help for a specific command: $ docker docker-subcommand --help Output of docker command: Management Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a containers changes cp Copy files/folders between a container and the local filesystem create Create a new container deploy Deploy a new stack or update an existing stack diff Inspect changes to files or directories on a containers filesystem events Get real time events from the server exec Run a command in a running container export Export a containers filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes","title":"More commands"},{"location":"docker/#removing-docker","text":"To remove Docker (noooo) in debian derivade linux: $ sudo apt-get remove docker docker-engine docker.io","title":"Removing docker"},{"location":"docker/#references","text":"Imagem e container Docker Docker command line Docker Docs","title":"References"},{"location":"your-own-image/","text":"Creating your own image There are two ways of creating an image: Commit and Dockerfile. Commit Create a container with: $ sudo docker container run -it --name container_name image_name /bin/bash You created and entered the container terminal. Install all you need and then type exit . Stop the container: $ sudo docker container stop container_name It stopped the container, now we can create a custom image of this container: $ sudo docker container commit container_name new_image_name Finished, type sudo docker images to see your new image! Dockerfile Dockerfile has the advantage to be an archive, so you can save this file somewhere and just build it to have your custom image. In commit mode you should install everything manually. To create an image with Dockerfile, create a empty folder and inside it create a file named Dockerfile. Inside this file you can configure the image how you want. As example, i will deploy this little project with nginx: html body h1 My Docker website with dockerfile /h1 /body /html My dockerfile looks like this: FROM nginx LABEL version= 1.0.0 description= Nginx website example maintainer= Leonardo Zanotti leonardojosezanotti@gmail.com RUN cd / mkdir Files chmod 777 -R Files/ COPY ./index.html /usr/share/nginx/html/ ADD http://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.tar.gz /temp/ VOLUME /Files/ EXPOSE 80 ENV API_URL=http://localhost:8000/api/ ENV API_DB=my_site WORKDIR /usr/share/nginx/html/ ENTRYPOINT [ /usr/sbin/nginx ] CMD [ -g , daemon off; ] The uppercase text are the docker commands (it doesnt need to be uppercase, its just for organization). The docker commands used are: FROM : It tells which image we are modifing, because a dockerfile is a modification of an existing image. Its common to use a whole linux distribuition in this field like debian:jessie . LABEL : Some informations about the image. RUN : Commands to be runned when the container starts. Here is just an example of creating folder, but you can install dependences here with sudo apt install (if you are using a image that runs on debin derivade linux). COPY : It copies files/folders from our machine to container. So here im using the copy to replace the index.html in nginx folder by my project. ADD : Add is like a copy with more features. The principal feature is extract tar local files or by URL. Im using it as example to extract a tar file by URL to the temp folder. VOLUME : Create a point where we can both pass and receive files from container. So, the files storaged in /Files will be storaged in your machine too and we doesnt gonna lose any file. EXPOSE : The port of the connection. Nginx use the 80 by default. ENV : Enviroment variables. WORKDIR : Folder of work. Is where we enter after running the container and all the RUN commands really are runned. ENTRYPOINT : Defines a folder to execute the CMD command. CMD : Command to be executed. So, in this example, we are running /usr/sbin/nginx -g daemon off; (basically starting nginx). Its interesting to see the Nginx dockerfile (which is our base image). It uses the ubuntu dockerfile as base image so if we want we can run apt commands in the RUN: # Nginx Dockerfile # https://github.com/dockerfile/nginx # Pull base image. FROM dockerfile/ubuntu # Install Nginx. RUN \\ add-apt-repository -y ppa:nginx/stable \\ apt-get update \\ apt-get install -y nginx \\ rm -rf /var/lib/apt/lists/* \\ echo \\ndaemon off; /etc/nginx/nginx.conf \\ chown -R www-data:www-data /var/lib/nginx # Define mountable directories. VOLUME [ /etc/nginx/sites-enabled , /etc/nginx/certs , /etc/nginx/conf.d , /var/log/nginx , /var/www/html ] # Define working directory. WORKDIR /etc/nginx # Define default command. CMD [ nginx ] # Expose ports. EXPOSE 80 EXPOSE 443 So, inside the folder you created (when your image is finished), you can build your image: $ sudo docker image build -t image_name . # sudo docker image build -t leonardozanotti/test-image . Now, if you type sudo docker images you image will be there. Then, we can run the image with: # How our Dockerfile is fully configured, we dont need to pass the `-e` and the `-v` arguments in the docker run. $ sudo docker run -d -p 80:80 --name image_name -e API_URL=http://api.mysite.com/api/ -v $PWD/Files:/Files/ full_image_name # sudo docker run -d -p 80:80 --name test-image -e API_URL=http://api.mysite.com/api/ -v $PWD/Files:/Files/ leonardozanotti/test-image At the end, just open localhost:80 to see the project: References Criando minha primeira imagem com docker Iniciando com docker e imagens Entendendo dockerfile","title":"Creating your own image"},{"location":"your-own-image/#creating-your-own-image","text":"There are two ways of creating an image: Commit and Dockerfile.","title":"Creating your own image"},{"location":"your-own-image/#commit","text":"Create a container with: $ sudo docker container run -it --name container_name image_name /bin/bash You created and entered the container terminal. Install all you need and then type exit . Stop the container: $ sudo docker container stop container_name It stopped the container, now we can create a custom image of this container: $ sudo docker container commit container_name new_image_name Finished, type sudo docker images to see your new image!","title":"Commit"},{"location":"your-own-image/#dockerfile","text":"Dockerfile has the advantage to be an archive, so you can save this file somewhere and just build it to have your custom image. In commit mode you should install everything manually. To create an image with Dockerfile, create a empty folder and inside it create a file named Dockerfile. Inside this file you can configure the image how you want. As example, i will deploy this little project with nginx: html body h1 My Docker website with dockerfile /h1 /body /html My dockerfile looks like this: FROM nginx LABEL version= 1.0.0 description= Nginx website example maintainer= Leonardo Zanotti leonardojosezanotti@gmail.com RUN cd / mkdir Files chmod 777 -R Files/ COPY ./index.html /usr/share/nginx/html/ ADD http://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.tar.gz /temp/ VOLUME /Files/ EXPOSE 80 ENV API_URL=http://localhost:8000/api/ ENV API_DB=my_site WORKDIR /usr/share/nginx/html/ ENTRYPOINT [ /usr/sbin/nginx ] CMD [ -g , daemon off; ] The uppercase text are the docker commands (it doesnt need to be uppercase, its just for organization). The docker commands used are: FROM : It tells which image we are modifing, because a dockerfile is a modification of an existing image. Its common to use a whole linux distribuition in this field like debian:jessie . LABEL : Some informations about the image. RUN : Commands to be runned when the container starts. Here is just an example of creating folder, but you can install dependences here with sudo apt install (if you are using a image that runs on debin derivade linux). COPY : It copies files/folders from our machine to container. So here im using the copy to replace the index.html in nginx folder by my project. ADD : Add is like a copy with more features. The principal feature is extract tar local files or by URL. Im using it as example to extract a tar file by URL to the temp folder. VOLUME : Create a point where we can both pass and receive files from container. So, the files storaged in /Files will be storaged in your machine too and we doesnt gonna lose any file. EXPOSE : The port of the connection. Nginx use the 80 by default. ENV : Enviroment variables. WORKDIR : Folder of work. Is where we enter after running the container and all the RUN commands really are runned. ENTRYPOINT : Defines a folder to execute the CMD command. CMD : Command to be executed. So, in this example, we are running /usr/sbin/nginx -g daemon off; (basically starting nginx). Its interesting to see the Nginx dockerfile (which is our base image). It uses the ubuntu dockerfile as base image so if we want we can run apt commands in the RUN: # Nginx Dockerfile # https://github.com/dockerfile/nginx # Pull base image. FROM dockerfile/ubuntu # Install Nginx. RUN \\ add-apt-repository -y ppa:nginx/stable \\ apt-get update \\ apt-get install -y nginx \\ rm -rf /var/lib/apt/lists/* \\ echo \\ndaemon off; /etc/nginx/nginx.conf \\ chown -R www-data:www-data /var/lib/nginx # Define mountable directories. VOLUME [ /etc/nginx/sites-enabled , /etc/nginx/certs , /etc/nginx/conf.d , /var/log/nginx , /var/www/html ] # Define working directory. WORKDIR /etc/nginx # Define default command. CMD [ nginx ] # Expose ports. EXPOSE 80 EXPOSE 443 So, inside the folder you created (when your image is finished), you can build your image: $ sudo docker image build -t image_name . # sudo docker image build -t leonardozanotti/test-image . Now, if you type sudo docker images you image will be there. Then, we can run the image with: # How our Dockerfile is fully configured, we dont need to pass the `-e` and the `-v` arguments in the docker run. $ sudo docker run -d -p 80:80 --name image_name -e API_URL=http://api.mysite.com/api/ -v $PWD/Files:/Files/ full_image_name # sudo docker run -d -p 80:80 --name test-image -e API_URL=http://api.mysite.com/api/ -v $PWD/Files:/Files/ leonardozanotti/test-image At the end, just open localhost:80 to see the project:","title":"Dockerfile"},{"location":"your-own-image/#references","text":"Criando minha primeira imagem com docker Iniciando com docker e imagens Entendendo dockerfile","title":"References"}]}